// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package main

import (
	"flag"
	"go/format"
	"go/types"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var outFile = flag.String("out", "", "output file")

func main() {
	flag.Parse()
	args := flag.Args()
	if len(args) == 0 {
		log.Print("tree package directory or files not specified")
		flag.Usage()
		os.Exit(2)
	}
	if *outFile == "" {
		log.Print("output file not specified")
		flag.Usage()
		os.Exit(2)
	}
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedTypes |
			packages.NeedTypesInfo | packages.NeedSyntax,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, args...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0]
	g := makeWalkGenerator(pkg.Types)
	g.generate()
	// Run gofmt on the result.
	result, err := format.Source([]byte(g.w.Result()))
	if err != nil {
		result = []byte(g.w.Result())
		log.Printf("warning: gofmt of tree walk code failed: %v", err)
	}

	file, err := os.Create(*outFile)
	if err != nil {
		log.Fatal("error creating file %s: %v", *outFile, err)
	}
	defer file.Close()

	if _, err := file.Write(result); err != nil {
		log.Fatal("error writing to file %s: %v", *outFile, err)
	}
}

type walkGenerator struct {
	ti typesInfo
	w  writer

	// generatedWalkFns keeps track of what walk<Type> functions we already
	// generated.
	generatedWalkFns map[string]bool
}

func makeWalkGenerator(pkg *types.Package) walkGenerator {
	return walkGenerator{
		ti:               makeTypesInfo(pkg),
		generatedWalkFns: make(map[string]bool),
	}
}

func (g *walkGenerator) generate() {
	typesWithWalkFnMap := make(map[string]struct{})
	var typesWithWalkFn []types.Type
	var gather func(t types.Type)
	gather = func(t types.Type) {
		if isPointer(t) {
			t = toPointer(t).Elem()
		}
		if isInterface(t) {
			return
		}
		if _, ok := typesWithWalkFnMap[t.String()]; ok {
			// Already gathered.
			return
		}
		if !g.ti.containsExprs(t) {
			return
		}
		typesWithWalkFnMap[t.String()] = struct{}{}
		typesWithWalkFn = append(typesWithWalkFn, t)
		switch t := t.Underlying().(type) {
		case *types.Slice:
			gather(t.Elem())

		case *types.Pointer:
			gather(t.Elem())

		case *types.Struct:
			for i := 0; i < t.NumFields(); i++ {
				gather(t.Field(i).Type())
			}
		}
	}
	for _, typ := range g.ti.allTypes {
		if g.ti.implementsStatement(typ) || g.ti.implementsExpr(typ) || g.ti.implementsTableExpr(typ) {
			gather(typ)
		}
	}
	sortTypes(typesWithWalkFn)
	g.w.Write("// Code generated by treegen; DO NOT EDIT.\n")
	g.w.Write("package tree\n")
	g.w.Write("// --- Walk code for Exprs ---")
	for _, typ := range g.ti.allTypes {
		if g.ti.implementsExpr(typ) {
			isPtr := !g.ti.hasTypeCheckMethod(typ)
			recvType := outType(typ)
			if isPtr {
				recvType = "*" + recvType
			}
			g.w.Write("\n// Walk implements the Expr interface.")
			if _, ok := typesWithWalkFnMap[typ.String()]; !ok {
				g.w.Write("func (expr %s) Walk(_ Visitor) Expr { return expr }", recvType)
				continue
			}
			g.w.Nest("func (expr %s) Walk(v Visitor) Expr {", recvType)
			g.w.Nest(
				"if newExpr, changed := %s(v, %sexpr); changed {",
				walkFnName(typ), maybe(isPtr, "*"),
			)
			g.w.Write("return %snewExpr", maybe(isPtr, "&"))
			g.w.Unnest("}")
			g.w.Write("return expr")
			g.w.Unnest("}")
			g.genWalkFn(typ)
		}
	}
	g.w.Write("\n// --- Walk code for Statements ---")
	for _, t := range typesWithWalkFn {
		if g.ti.implementsStatement(t) {
			g.w.Write("\nvar _ walkableStmt = (*%s)(nil)\n", outType(t))
			g.w.Write("// walkStmt implements the Expr interface.")
			g.w.Nest("func (stmt *%s) walkStmt(v Visitor) (_ Statement, changed bool) {", outType(t))
			g.w.Nest("if newStmt, changed := %s(v, *stmt); changed {", walkFnName(t))
			g.w.Write("return &newStmt, true")
			g.w.Unnest("}")
			g.w.Write("return stmt, false")
			g.w.Unnest("}")
			g.genWalkFn(t)
		}
	}
	g.w.Write("\n// --- Walk code for TableExprs ---")
	for _, t := range g.ti.allTypes {
		if g.ti.implementsTableExpr(t) {
			g.w.Write("")
			g.w.Write("var _ TableExpr = (*%s)(nil)\n", outType(t))
			g.w.Write("// WalkTableExpr implements the TableExpr interface.")
			if _, hasWalkFn := typesWithWalkFnMap[t.String()]; !hasWalkFn {
				g.w.Write("func (expr *%s) WalkTableExpr(v Visitor) (_ TableExpr, changed bool) { return expr, false }", outType(t))
			} else {
				g.w.Nest("func (expr *%s) WalkTableExpr(v Visitor) (_ TableExpr, changed bool) {", outType(t))
				g.w.Nest("if newExpr, changed := %s(v, *expr); changed {", walkFnName(t))
				g.w.Write("return &newExpr, true")
				g.w.Unnest("}")
				g.w.Write("return expr, false")
				g.w.Unnest("}")
				g.genWalkFn(t)
			}
		}
	}
	g.w.Write("\n// --- Walk code for helpers ---")
	for _, t := range typesWithWalkFn {
		if !g.ti.implementsExpr(t) && !g.ti.implementsStatement(t) && !g.ti.implementsTableExpr(t) {
			g.genWalkFn(t)
		}
	}
}

func walkFnName(t types.Type) string {
	if isPointer(t) {
		log.Fatal("walkFnName should not be called on pointer type")
	}
	name := types.TypeString(t, func(pkg *types.Package) string { return "" })
	name = strings.ReplaceAll(name, "[]", "SliceOf")
	name = strings.ReplaceAll(name, "*", "Star")
	if name == "Expr" {
		return "WalkExpr"
	}
	return "walk" + name
}

// genWalkFn generates a walk<Type> function for the given type (unless it was
// already generated).
func (g *walkGenerator) genWalkFn(t types.Type) {
	if g.generatedWalkFns[walkFnName(t)] {
		return
	}
	g.generatedWalkFns[walkFnName(t)] = true
	g.w.Write("")
	g.w.Nest("func %s(v Visitor, n %s) (_ %s, changed bool) {", walkFnName(t), outType(t), outType(t))
	switch u := t.Underlying().(type) {
	case *types.Slice:
		elem := u.Elem()
		g.w.Nest("for i := range n {")
		if !isPointer(elem) {
			g.w.Nest("if newElem, elemChanged := %s(v, n[i]); elemChanged {", walkFnName(elem))
			{
				g.w.Nest("if !changed {")
				g.w.Write("n = append(%s(nil), n...)", outType(t))
				g.w.Write("changed = true")
				g.w.Unnest("}")
			}
			g.w.Write("n[i] = newElem")
			g.w.Unnest("}")
		} else {
			elem = toPointer(elem).Elem()
			g.w.Nest("if newElem, elemChanged := %s(v, *n[i]); elemChanged {", walkFnName(elem))
			{
				g.w.Nest("if !changed {")
				g.w.Write("n = append(%s(nil), n...)", outType(t))
				g.w.Write("changed = true")
				g.w.Unnest("}")
			}
			g.w.Write("n[i] = &newElem")
			g.w.Unnest("}")
		}
		g.w.Unnest("}")
		g.w.Write("return n, changed")

	case *types.Struct:
		// See which fields need to be walked.
		var fields []*types.Var
		for i := 0; i < u.NumFields(); i++ {
			f := u.Field(i)
			if g.ti.containsExprs(f.Type()) {
				fields = append(fields, f)
			}
		}
		for _, f := range fields {
			typ := f.Type()
			isPtr := isPointer(typ)
			if isPtr {
				typ = toPointer(typ).Elem()
				g.w.Nest("if n.%s != nil {", f.Name())
			}
			g.w.Nest(
				"if new%[1]s, changed%[1]s := %[2]s(v, %[3]sn.%[1]s); changed%[1]s {",
				f.Name(), walkFnName(typ), maybe(isPtr, "*"),
			)
			g.w.Write("n.%[1]s = %[2]snew%[1]s", f.Name(), maybe(isPtr, "&"))
			g.w.Write("changed = true")
			g.w.Unnest("}")
			if isPtr {
				g.w.Unnest("}")
			}
		}
		g.w.Write("return n, changed")

	default:
		log.Fatalf("unsupported type %v", t)
	}
	g.w.Unnest("}")
}

// maybe returns trueStr if cond is true, otherwise the empty string.
func maybe(cond bool, trueStr string) string {
	if cond {
		return trueStr
	}
	return ""
}
